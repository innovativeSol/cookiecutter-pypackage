{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Project Wizard for AWS CodeArtifact \u00b6 A tool for creating skeleton Python project, built with popular develop tools and conform to best practice. The packages are setup to deploy to AWS CodeArtifact. The template system used is CookieCutter . Features \u00b6 This tool will create Python project with the following features: Poetry : Manage version, dependancy, build and release Mkdocs : Writting your docs in markdown style Testing with Pytest (unittest is still supported out of the box) Code coverage report and endorsed by Codecov Tox : Test your code against environment matrix, lint and artifact check. Format with Black and Isort Lint code with Flake8 and Flake8-docstrings Pre-commit hooks : Formatting/linting anytime when commit/run local tox/CI Mkdocstrings : Auto API doc generation Command line interface using Python Fire (optional) Continuous Integration/Deployment by github actions , includes: publish dev build/official release to AWS CodeArtifact automatically when CI success publish documents automatically when CI success extract change log from github and integrate with release notes automatically Host your documentation from Git Pages with zero-config Quickstart \u00b6 Install aws-ppw if you haven't install it yet: 1 pip install -U git+https://github.com/innovativeSol/innovative-pip-cookiecutter-pypackage Generate a Python package project by simple run: 1 aws-ppw Template Information \u00b6 The CookieCutter template starts with the {{cookiecutter.project_slug}} , and yes the {}s are part of the folder name. The output of the template will be the following. We will use a project_slug of my_project . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . \u2514\u2500\u2500 my_project \u251c\u2500\u2500 AUTHORS.md \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 .coveragerc \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 api.md \u2502 \u251c\u2500\u2500 authors.md \u2502 \u251c\u2500\u2500 contributing.md \u2502 \u251c\u2500\u2500 history.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 installation.md \u2502 \u2514\u2500\u2500 usage.md \u251c\u2500\u2500 .editorconfig \u251c\u2500\u2500 .flake8 \u251c\u2500\u2500 .git \u251c\u2500\u2500 .github \u2502 \u251c\u2500\u2500 ISSUE_TEMPLATE.md \u2502 \u2514\u2500\u2500 workflows \u2502 \u251c\u2500\u2500 dev.yml \u2502 \u2514\u2500\u2500 release.yml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 HISTORY.md \u251c\u2500\u2500 .isort.cfg \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 my_project \u2502 \u251c\u2500\u2500 cli.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 my_project.py \u251c\u2500\u2500 .pre-commit-config.yaml \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 pyrightconfig.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 site \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 test_my_project.py \u2514\u2500\u2500 tox.ini If you look through the contents of the {{cookiecutter.project_slug}} folder, you will notice that there is a github folder instead of a .github folder. This is because CookieCutter does not process files in folders that start with a period. The renaming of this folder is done in the CookieCutter post generation hook found in hooks/post_gen_project.py . Notice the contents of top level my_project will contain a .git folder. You can set the origin in this git configuration or copy everything except that folder to an empty cloned repository of your choice. To install the pre-commit hooks, make sure to run pre-commit install from the root of the repository. Follow Tutorial to finish other configurations. Credits \u00b6 This repo is forked from zillionare/cookiecutter-pypackage , and borrowed some updates from ma7555","title":"Introduction"},{"location":"#python-project-wizard-for-aws-codeartifact","text":"A tool for creating skeleton Python project, built with popular develop tools and conform to best practice. The packages are setup to deploy to AWS CodeArtifact. The template system used is CookieCutter .","title":"Python Project Wizard for AWS CodeArtifact"},{"location":"#features","text":"This tool will create Python project with the following features: Poetry : Manage version, dependancy, build and release Mkdocs : Writting your docs in markdown style Testing with Pytest (unittest is still supported out of the box) Code coverage report and endorsed by Codecov Tox : Test your code against environment matrix, lint and artifact check. Format with Black and Isort Lint code with Flake8 and Flake8-docstrings Pre-commit hooks : Formatting/linting anytime when commit/run local tox/CI Mkdocstrings : Auto API doc generation Command line interface using Python Fire (optional) Continuous Integration/Deployment by github actions , includes: publish dev build/official release to AWS CodeArtifact automatically when CI success publish documents automatically when CI success extract change log from github and integrate with release notes automatically Host your documentation from Git Pages with zero-config","title":"Features"},{"location":"#quickstart","text":"Install aws-ppw if you haven't install it yet: 1 pip install -U git+https://github.com/innovativeSol/innovative-pip-cookiecutter-pypackage Generate a Python package project by simple run: 1 aws-ppw","title":"Quickstart"},{"location":"#template-information","text":"The CookieCutter template starts with the {{cookiecutter.project_slug}} , and yes the {}s are part of the folder name. The output of the template will be the following. We will use a project_slug of my_project . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . \u2514\u2500\u2500 my_project \u251c\u2500\u2500 AUTHORS.md \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 .coveragerc \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 api.md \u2502 \u251c\u2500\u2500 authors.md \u2502 \u251c\u2500\u2500 contributing.md \u2502 \u251c\u2500\u2500 history.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 installation.md \u2502 \u2514\u2500\u2500 usage.md \u251c\u2500\u2500 .editorconfig \u251c\u2500\u2500 .flake8 \u251c\u2500\u2500 .git \u251c\u2500\u2500 .github \u2502 \u251c\u2500\u2500 ISSUE_TEMPLATE.md \u2502 \u2514\u2500\u2500 workflows \u2502 \u251c\u2500\u2500 dev.yml \u2502 \u2514\u2500\u2500 release.yml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 HISTORY.md \u251c\u2500\u2500 .isort.cfg \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 my_project \u2502 \u251c\u2500\u2500 cli.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 my_project.py \u251c\u2500\u2500 .pre-commit-config.yaml \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 pyrightconfig.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 site \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 test_my_project.py \u2514\u2500\u2500 tox.ini If you look through the contents of the {{cookiecutter.project_slug}} folder, you will notice that there is a github folder instead of a .github folder. This is because CookieCutter does not process files in folders that start with a period. The renaming of this folder is done in the CookieCutter post generation hook found in hooks/post_gen_project.py . Notice the contents of top level my_project will contain a .git folder. You can set the origin in this git configuration or copy everything except that folder to an empty cloned repository of your choice. To install the pre-commit hooks, make sure to run pre-commit install from the root of the repository. Follow Tutorial to finish other configurations.","title":"Template Information"},{"location":"#credits","text":"This repo is forked from zillionare/cookiecutter-pypackage , and borrowed some updates from ma7555","title":"Credits"},{"location":"console_script_setup/","text":"Console Script Setup \u00b6 Optionally, your package can include a console script using Fire How It Works \u00b6 If the command_line_interface option is set to fire during setup, cookiecutter will add a file cli.py in the project_slug subdirectory. An entry point is added to pyproject.toml that points to the main function in cli.py. Usage \u00b6 To use the console script in development: 1 poetry install projectdir should be the top level project directory with the pyproject.toml file Then execute: 1 $your_package_name help it will show your package name, project short description and exit. More Details \u00b6 You can read more about Python Fire at Fire","title":"Console script"},{"location":"console_script_setup/#console-script-setup","text":"Optionally, your package can include a console script using Fire","title":"Console Script Setup"},{"location":"console_script_setup/#how-it-works","text":"If the command_line_interface option is set to fire during setup, cookiecutter will add a file cli.py in the project_slug subdirectory. An entry point is added to pyproject.toml that points to the main function in cli.py.","title":"How It Works"},{"location":"console_script_setup/#usage","text":"To use the console script in development: 1 poetry install projectdir should be the top level project directory with the pyproject.toml file Then execute: 1 $your_package_name help it will show your package name, project short description and exit.","title":"Usage"},{"location":"console_script_setup/#more-details","text":"You can read more about Python Fire at Fire","title":"More Details"},{"location":"faq/","text":"FAQ \u00b6 Question Why github workflow release & publish failed? \u00b6 We have used a github action heinrichreimer/github-changelog-generator-action to generate change log automatically for your project. However, this action requires some configuration. Goto .github/workflows/release.yml (in your project folder), find the following: 1 2 3 4 5 6 7 8 9 10 11 12 - name: generate change log uses: heinrichreimer/github-changelog-generator-action@v2.1.1 with: token: ${{ secrets.GITHUB_TOKEN }} issues: true issuesWoLabels: true pullRequests: true prWoLabels: true unreleased: true addSections: '{\"documentation\":{\"prefix\":\"**Documentation:**\",\"labels\":[\"documentation\"]}}' #sinceTag: v0.1.1 output: CHANGELOG.md uncomment #sinceTag line and given an existed tag name in your project. If there's none, you have to create one now. Question Why not travis CI? \u00b6 Travis CI is a great service, however, github actions is super convenient, less configuration , better integration. Less configuration, less error prone. Question Why not read the docs? \u00b6 Same reason as above. Git pages is convenient than read the docs, it requires no further configuration, except access token. As to read the docs, you need to write v2 config file, plus several settings on web pages. Question Why mkdocs over sphinx? \u00b6 reStructured Text and Sphinx is way to tedious, though powerful. With extension, you'll find almost all features are available in mkdocs, in a neat and productive way. Poetry and Markdown, are the two key factors driven me develop this template. Question What are the configuration items? \u00b6 Here is a list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ## Templated Values The following appear in various parts of your generated project. full_name Your full name. email Your email address. github_user_or_org_name Your GitHub user or organization name. project_name The name of your new Python package project. This is used in documentation, so spaces and any characters are fine here. project_slug The namespace of your Python package. This should be Python import-friendly. Typically, it is the slugified version of project_name. project_short_description A 1-sentence description of what your Python package does. release_date The date of the first release. year The year of the initial package copyright in the license file. version The starting version number of the package. install_precommit_hooks If you choose yes, then cookiecutter will install pre-commit hooks for you. docstrings_style one of `google, numpy, rst`. It's required by flake8-docstrings. ## Options The following package configuration options set up different features for your project. command_line_interface Whether to create a console script using Python Fire. Console script entry point will match the project_slug. Options: \\['fire', \"No command-line interface\"\\] except above settings, for CI/CD, you'll also need configure gitub repsitory secrets at page repo > settings > secrtes, and add the following secrets: PERSONAL_TOKEN (required for publishing document to git pages) TEST_PYPI_API_TOKEN (required for publishing dev release to testpypi) PYPI_API_TOKEN (required for publish )","title":"FAQ"},{"location":"faq/#faq","text":"Question","title":"FAQ"},{"location":"faq/#why-github-workflow-release--publish-failed","text":"We have used a github action heinrichreimer/github-changelog-generator-action to generate change log automatically for your project. However, this action requires some configuration. Goto .github/workflows/release.yml (in your project folder), find the following: 1 2 3 4 5 6 7 8 9 10 11 12 - name: generate change log uses: heinrichreimer/github-changelog-generator-action@v2.1.1 with: token: ${{ secrets.GITHUB_TOKEN }} issues: true issuesWoLabels: true pullRequests: true prWoLabels: true unreleased: true addSections: '{\"documentation\":{\"prefix\":\"**Documentation:**\",\"labels\":[\"documentation\"]}}' #sinceTag: v0.1.1 output: CHANGELOG.md uncomment #sinceTag line and given an existed tag name in your project. If there's none, you have to create one now. Question","title":"Why github workflow release &amp; publish failed?"},{"location":"faq/#why-not-travis-ci","text":"Travis CI is a great service, however, github actions is super convenient, less configuration , better integration. Less configuration, less error prone. Question","title":"Why not travis CI?"},{"location":"faq/#why-not-read-the-docs","text":"Same reason as above. Git pages is convenient than read the docs, it requires no further configuration, except access token. As to read the docs, you need to write v2 config file, plus several settings on web pages. Question","title":"Why not read the docs?"},{"location":"faq/#why-mkdocs-over-sphinx","text":"reStructured Text and Sphinx is way to tedious, though powerful. With extension, you'll find almost all features are available in mkdocs, in a neat and productive way. Poetry and Markdown, are the two key factors driven me develop this template. Question","title":"Why mkdocs over sphinx?"},{"location":"faq/#what-are-the-configuration-items","text":"Here is a list: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ## Templated Values The following appear in various parts of your generated project. full_name Your full name. email Your email address. github_user_or_org_name Your GitHub user or organization name. project_name The name of your new Python package project. This is used in documentation, so spaces and any characters are fine here. project_slug The namespace of your Python package. This should be Python import-friendly. Typically, it is the slugified version of project_name. project_short_description A 1-sentence description of what your Python package does. release_date The date of the first release. year The year of the initial package copyright in the license file. version The starting version number of the package. install_precommit_hooks If you choose yes, then cookiecutter will install pre-commit hooks for you. docstrings_style one of `google, numpy, rst`. It's required by flake8-docstrings. ## Options The following package configuration options set up different features for your project. command_line_interface Whether to create a console script using Python Fire. Console script entry point will match the project_slug. Options: \\['fire', \"No command-line interface\"\\] except above settings, for CI/CD, you'll also need configure gitub repsitory secrets at page repo > settings > secrtes, and add the following secrets: PERSONAL_TOKEN (required for publishing document to git pages) TEST_PYPI_API_TOKEN (required for publishing dev release to testpypi) PYPI_API_TOKEN (required for publish )","title":"What are the configuration items?"},{"location":"history/","text":"v1.0 \u00b6 first release with the following features: Poetry : Manage version, dependancy, build and release Mkdocs : Writting your docs in markdown style Testing with Pytest (unittest is still supported out of the box) Code coverage report and endorsed by Codecov Tox : Test your code against environment matrix, lint and artifact check. Format with Black and Isort Lint code with Flake8 and Flake8-docstrings Pre-commit hooks : Formatting/linting anytime when commit/run local tox/CI Mkdocstrings : Auto API doc generation Command line interface using Python Fire (optional) Continuouse Integration/Deployment by github actions , includes: publish dev build/official release to AWS CodeArtifact automatically when CI success publish documents automatically when CI success extract change log from github and integrate with release notes automatically Host your documentation from Git Pages with zero-config","title":"History"},{"location":"history/#v10","text":"first release with the following features: Poetry : Manage version, dependancy, build and release Mkdocs : Writting your docs in markdown style Testing with Pytest (unittest is still supported out of the box) Code coverage report and endorsed by Codecov Tox : Test your code against environment matrix, lint and artifact check. Format with Black and Isort Lint code with Flake8 and Flake8-docstrings Pre-commit hooks : Formatting/linting anytime when commit/run local tox/CI Mkdocstrings : Auto API doc generation Command line interface using Python Fire (optional) Continuouse Integration/Deployment by github actions , includes: publish dev build/official release to AWS CodeArtifact automatically when CI success publish documents automatically when CI success extract change log from github and integrate with release notes automatically Host your documentation from Git Pages with zero-config","title":"v1.0"},{"location":"pypi_release_checklist/","text":"PyPI Release Checklist \u00b6 For Every Release \u00b6 Check out release branch, merge all changes from master/main to release Run the tests: 1 tox Update HISTORY.md Be noticed that github workflow will generate a changelog for you automatically. Commit the changes: 1 2 git add HISTORY.md git commit -m \"Changelog for upcoming release 0.1.1.\" Update version number. The following are an example of executing and the contents of the push-version.ps1 script at the root of the repository. 1 .\\ push-version . ps1 1 . 1 . 25 \"documentation updates\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- BEGIN INCLUDE ../ push-version . ps1 --> param ( [ Parameter ( Mandatory , HelpMessage = \"Enter a valid version number #.#.#\" )] [ ValidatePattern ( \"\\d+\\.\\d+\\.\\d+\" )] [string] $version , [ Parameter ( Mandatory )] [string] $message ) poetry version $version # update the version in pyproject.toml git add -A # add the updated pyproject.toml git commit -m \"v$version\" git tag v $version -m $message git push - -atomic origin master v $version <!-- END INCLUDE --> Check the CodeArtifact listing page to make sure that the README, release notes, and roadmap display properly. If tox test passed, this should be ok, since we have already run twine check during tox test.","title":"Release checklist"},{"location":"pypi_release_checklist/#pypi-release-checklist","text":"","title":"PyPI Release Checklist"},{"location":"pypi_release_checklist/#for-every-release","text":"Check out release branch, merge all changes from master/main to release Run the tests: 1 tox Update HISTORY.md Be noticed that github workflow will generate a changelog for you automatically. Commit the changes: 1 2 git add HISTORY.md git commit -m \"Changelog for upcoming release 0.1.1.\" Update version number. The following are an example of executing and the contents of the push-version.ps1 script at the root of the repository. 1 .\\ push-version . ps1 1 . 1 . 25 \"documentation updates\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <!-- BEGIN INCLUDE ../ push-version . ps1 --> param ( [ Parameter ( Mandatory , HelpMessage = \"Enter a valid version number #.#.#\" )] [ ValidatePattern ( \"\\d+\\.\\d+\\.\\d+\" )] [string] $version , [ Parameter ( Mandatory )] [string] $message ) poetry version $version # update the version in pyproject.toml git add -A # add the updated pyproject.toml git commit -m \"v$version\" git tag v $version -m $message git push - -atomic origin master v $version <!-- END INCLUDE --> Check the CodeArtifact listing page to make sure that the README, release notes, and roadmap display properly. If tox test passed, this should be ok, since we have already run twine check during tox test.","title":"For Every Release"},{"location":"tutorial/","text":"Tutorial \u00b6 Note Did you find this article confusing? Edit this file and pull a request! To start with, you will need GitHub , Pypi , TestPyPi and Codecov account. If you don't have one, please follow the links to apply one before you get started on this tutorial. If you are new to Git and GitHub, you should probably spend a few minutes on some of the tutorials at the top of the page at GitHub Help Step 1: Install Python Project Wizard (aws_ppw) \u00b6 Install aws_ppw: 1 pip install aws_ppw Step 2: Generate Your Package \u00b6 Now it's time to generate your Python package. Run the following command and feed with answers: 1 aws_ppw Finally a new folder will be created under current folder, the name is the answer you provided to project_slug . The project layout should looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 . \u251c\u2500\u2500 AUTHORS.md \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 .coveragerc \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 api.md \u2502 \u251c\u2500\u2500 authors.md \u2502 \u251c\u2500\u2500 contributing.md \u2502 \u251c\u2500\u2500 history.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 installation.md \u2502 \u2514\u2500\u2500 usage.md \u251c\u2500\u2500 .editorconfig \u251c\u2500\u2500 .flake8 \u251c\u2500\u2500 .github \u2502 \u251c\u2500\u2500 ISSUE_TEMPLATE.md \u2502 \u2514\u2500\u2500 workflows \u2502 \u251c\u2500\u2500 dev.yml \u2502 \u2514\u2500\u2500 release.yml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 HISTORY.md \u251c\u2500\u2500 .isort.cfg \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 ppw_0420_01 \u2502 \u251c\u2500\u2500 cli.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ppw_0420_01.py \u251c\u2500\u2500 .pre-commit-config.yaml \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 pyrightconfig.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 site \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 test_ppw_0420_01.py \u2514\u2500\u2500 tox.ini Here the project_slug is ppw_0420_01, when you generate yours, it could be other name. Also be noticed that there's pyproject.toml in this folder. This is the main configuration file of our project. Step 3: Build a Virtual Environment and Install Dev Requirements \u00b6 You should still be in the folder named as %proejct_slug , which containing the pyproject.toml file. Install the new project's local development requirements inside a virtual environment: 1 2 3 pip install poetry poetry install -E dev tox We start with install poetry, since the whole project is managed by poetry. Then we installed extra dependency need by developer, such as documentation build tools, lint, formatting and test tools etc. We also launch a smoke test here by running tox . This will give you a test report and lint report. You should see no errors except some lint warnings. Tips Extra dependencies are grouped into three groups, doc, dev and test for better granularity. When you ship the package, dependencies in group doc, dev and test might not be shipped. As the developer, you will need install all the dependencies. Tips if you found erros like the following during tox run: 1 ERROR: InterpreterNotFound: python3.9 don't be panic, this is just because python3.x is not found on your machine. If you decide to support that version of Python in your package, please install it on your machine. Otherwise, remove it from tox.ini and pyproject.toml (search python3.x then remove it). Step 4: Create a GitHub Repo \u00b6 Go to your GitHub account and create a new repo named mypackage , where mypackage matches the [project_slug] from your answers to running cookiecutter. Then goto repo > settings > secrets, click on 'New repository secret', add the following secrets: DEV_CODEARTIFACT_ROLE_ARN, see How to apply testpypi token PYPI_API_TOKEN, see How to apply pypi token PERSONAL_TOKEN, see How to apply personal token Step 6: Set Up codecov integration \u00b6 Tips If you have already setup codecov integration and configured access for all your repositories, you can skip this step. In your browser, visit install codecov app , you'll be landed at this page: Click on the green install button at top right, choose all repositories then click on install button, following directions until all set. Step 7: Upload code to github \u00b6 Back to your develop environment, find the folder named after the [project_slug] . Move into this folder, and then setup git to use your GitHub repo and upload the code: 1 2 3 4 5 6 7 cd mypackage git add . git commit -m \"Initial skeleton.\" git branch -M main git remote add origin git@github.com:myusername/mypackage.git git push -u origin main Where myusername and mypackage are adjusted for your username and package name. You'll need a ssh key to push the repo. You can Generate a key or Add an existing one. Warning if you answered 'yes' to the question if install pre-commit hooks at last step, then you should find pre-commit be invoked when you run git commit , and some files may be modified by hooks. If so, please add these files and commit again . Check result \u00b6 After pushing your code to github, goto github web page, navigate to your repo, then click on actions link, you should find screen like this: There should be one workflow running. After it finished, go to [testpyi], check if a new artifact is published under the name {{ cookiecutter.project_slug }} Step 8. Check documentation \u00b6 Documentation will be published and available at https://{your_github_account}.github.io/{your_repo} once: the branch is release the commit is tagged, and the tag name is started with 'v' (lower case) build/testing executed by github CI passed If you'd like to see what it's look like now, you could run the followng command: 1 mkdocs gh-deploy then check your documentation at https://{your_github_account}.github.io/{your_repo} Step 9. Make official release \u00b6 After done with your phased development, switch to release branch, following instructions at release checklist , trigger first official release and check result at PYPI .","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Note Did you find this article confusing? Edit this file and pull a request! To start with, you will need GitHub , Pypi , TestPyPi and Codecov account. If you don't have one, please follow the links to apply one before you get started on this tutorial. If you are new to Git and GitHub, you should probably spend a few minutes on some of the tutorials at the top of the page at GitHub Help","title":"Tutorial"},{"location":"tutorial/#step-1-install-python-project-wizard-aws_ppw","text":"Install aws_ppw: 1 pip install aws_ppw","title":"Step 1: Install Python Project Wizard (aws_ppw)"},{"location":"tutorial/#step-2-generate-your-package","text":"Now it's time to generate your Python package. Run the following command and feed with answers: 1 aws_ppw Finally a new folder will be created under current folder, the name is the answer you provided to project_slug . The project layout should looks like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 . \u251c\u2500\u2500 AUTHORS.md \u251c\u2500\u2500 CONTRIBUTING.md \u251c\u2500\u2500 .coveragerc \u251c\u2500\u2500 dist \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 api.md \u2502 \u251c\u2500\u2500 authors.md \u2502 \u251c\u2500\u2500 contributing.md \u2502 \u251c\u2500\u2500 history.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 installation.md \u2502 \u2514\u2500\u2500 usage.md \u251c\u2500\u2500 .editorconfig \u251c\u2500\u2500 .flake8 \u251c\u2500\u2500 .github \u2502 \u251c\u2500\u2500 ISSUE_TEMPLATE.md \u2502 \u2514\u2500\u2500 workflows \u2502 \u251c\u2500\u2500 dev.yml \u2502 \u2514\u2500\u2500 release.yml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 HISTORY.md \u251c\u2500\u2500 .isort.cfg \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 mkdocs.yml \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 ppw_0420_01 \u2502 \u251c\u2500\u2500 cli.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 ppw_0420_01.py \u251c\u2500\u2500 .pre-commit-config.yaml \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 pyrightconfig.json \u251c\u2500\u2500 README.md \u251c\u2500\u2500 site \u251c\u2500\u2500 tests \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 test_ppw_0420_01.py \u2514\u2500\u2500 tox.ini Here the project_slug is ppw_0420_01, when you generate yours, it could be other name. Also be noticed that there's pyproject.toml in this folder. This is the main configuration file of our project.","title":"Step 2: Generate Your Package"},{"location":"tutorial/#step-3-build-a-virtual-environment-and-install-dev-requirements","text":"You should still be in the folder named as %proejct_slug , which containing the pyproject.toml file. Install the new project's local development requirements inside a virtual environment: 1 2 3 pip install poetry poetry install -E dev tox We start with install poetry, since the whole project is managed by poetry. Then we installed extra dependency need by developer, such as documentation build tools, lint, formatting and test tools etc. We also launch a smoke test here by running tox . This will give you a test report and lint report. You should see no errors except some lint warnings. Tips Extra dependencies are grouped into three groups, doc, dev and test for better granularity. When you ship the package, dependencies in group doc, dev and test might not be shipped. As the developer, you will need install all the dependencies. Tips if you found erros like the following during tox run: 1 ERROR: InterpreterNotFound: python3.9 don't be panic, this is just because python3.x is not found on your machine. If you decide to support that version of Python in your package, please install it on your machine. Otherwise, remove it from tox.ini and pyproject.toml (search python3.x then remove it).","title":"Step 3: Build a Virtual Environment and Install Dev Requirements"},{"location":"tutorial/#step-4-create-a-github-repo","text":"Go to your GitHub account and create a new repo named mypackage , where mypackage matches the [project_slug] from your answers to running cookiecutter. Then goto repo > settings > secrets, click on 'New repository secret', add the following secrets: DEV_CODEARTIFACT_ROLE_ARN, see How to apply testpypi token PYPI_API_TOKEN, see How to apply pypi token PERSONAL_TOKEN, see How to apply personal token","title":"Step 4: Create a GitHub Repo"},{"location":"tutorial/#step-6-set-up-codecov-integration","text":"Tips If you have already setup codecov integration and configured access for all your repositories, you can skip this step. In your browser, visit install codecov app , you'll be landed at this page: Click on the green install button at top right, choose all repositories then click on install button, following directions until all set.","title":"Step 6: Set Up codecov integration"},{"location":"tutorial/#step-7-upload-code-to-github","text":"Back to your develop environment, find the folder named after the [project_slug] . Move into this folder, and then setup git to use your GitHub repo and upload the code: 1 2 3 4 5 6 7 cd mypackage git add . git commit -m \"Initial skeleton.\" git branch -M main git remote add origin git@github.com:myusername/mypackage.git git push -u origin main Where myusername and mypackage are adjusted for your username and package name. You'll need a ssh key to push the repo. You can Generate a key or Add an existing one. Warning if you answered 'yes' to the question if install pre-commit hooks at last step, then you should find pre-commit be invoked when you run git commit , and some files may be modified by hooks. If so, please add these files and commit again .","title":"Step 7: Upload code to github"},{"location":"tutorial/#check-result","text":"After pushing your code to github, goto github web page, navigate to your repo, then click on actions link, you should find screen like this: There should be one workflow running. After it finished, go to [testpyi], check if a new artifact is published under the name {{ cookiecutter.project_slug }}","title":"Check result"},{"location":"tutorial/#step-8-check-documentation","text":"Documentation will be published and available at https://{your_github_account}.github.io/{your_repo} once: the branch is release the commit is tagged, and the tag name is started with 'v' (lower case) build/testing executed by github CI passed If you'd like to see what it's look like now, you could run the followng command: 1 mkdocs gh-deploy then check your documentation at https://{your_github_account}.github.io/{your_repo}","title":"Step 8. Check documentation"},{"location":"tutorial/#step-9-make-official-release","text":"After done with your phased development, switch to release branch, following instructions at release checklist , trigger first official release and check result at PYPI .","title":"Step 9. Make official release"}]}